"""Domain classes and functions related to the concept of musician
"""


#%%
# Setup / Data

from music.enums import Vocals, Instrument


#%%
class Musician:
    """The class describing the concept of musician.
    It is assumed that a musician is sufficiently described by their
    name and whether they are a solo musician or a member of a band.

    This class illustrates some important concepts of Python classes:
    - self
    - __init__()
    - __str__()
    - __eq__(self, other) is the equivalent of Java equals() and should be overridden in classes
    - __dict__ attribute of all objects
    - data fields (instance variables)
    - methods - calling them by self.<method>(...) from the same class where they are defined
    """

    def __init__(self, name, is_band_member=True):
        self.name = name
        self.is_band_member = is_band_member

    def __str__(self):
        b = '(band member)' if self.is_band_member else '(solo musician)'
        return f'{self.name} {b}'

    def __eq__(self, other):
        i = isinstance(other, Musician)
        n = self.name == other.name if i else False
        bm = self.is_band_member == other.is_band_member if i else False
        return i and n and bm

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, name):
        self.__name = name if isinstance(name, str) else 'unknown'

    def play(self, song_title, *args, **kwargs):
        """Assumes that song_title, *args (expressions of gratitude) and kwargs.values() (messages) are strings.
        Prints song_title, rhythm counts, expressions of gratitude and messages. A call example:
            <musician>.play(song_title, *['Thank you!', 'You're wonderful!], love='We love you!')
        Convention: if rhythm count is provided, it is passed as rhythm_count='...' and is the first kwarg.
        """

        n = self.name
        s = f'"{song_title}"'
        r = kwargs['rhythm_count'] if 'rhythm_count' in kwargs.keys() else ''
        g = ' '.join([a for a in args]) if args else ''
        m = ' '.join([v for v in list(kwargs.values())[1:]]) if list(kwargs.values())[1:] else ''

        return f'{n} playing {s}: {r} ...playing... {g} {m}'

    def play_song(self, song_title, *args, **kwargs):
        """Demonstrates calling another method from the same class (self.<method>(...) as a mandatory syntax).
        """

        return self.play(song_title, *args, **kwargs)

    # Alternative constructor
    @classmethod
    def from_str(cls, musician_string):
        """Inverted __str__() method.
        Assumes that musician_string is in the format generated by __str__().
        """

        # b = '(band member)' if self.is_band_member else '(solo musician)'
        # return f'{self.name} {b}'
        n = musician_string.split(' (')[0]
        bm = True if musician_string.split(' (')[1].startswith('b') else False
        return cls(n, bm)


#%%
class Singer(Musician):
    """The class describing the concept of singer.
    It is assumed that a singer is sufficiently described as a Musician,
    with the addition of whether they are a lead or a background singer.
    """

    def __init__(self, vocals=Vocals.LEAD_VOCALS, **kwargs):
        super().__init__(**kwargs)
        self.vocals = vocals if isinstance(vocals, Vocals) else None

    def __str__(self):
        v = f', {self.vocals.value}' if isinstance(self.vocals, Vocals) else ''
        return super().__str__() + v

    def __eq__(self, other):
        pass
        # Recommended if inheritance is involved
        # (https://stackoverflow.com/questions/390250/elegant-ways-to-support-equivalence-equality-in-python-classes):
        # if type(other) is type(self):
        #     return self.__dict__ == other.__dict__
        # return False

        return self.__dict__ == other.__dict__ if isinstance(other, Singer) else False

    def play(self, song_title, *args, **kwargs):
        """Overrides the play() method from superclass.
        In addition to printing song_title, expressions of gratitude and messages,
        it also prints an additional message in the end.
        A call example:
            <singer>.play(song_title, *['Thank you!', 'You're wonderful!], love='We love you!')
        """

        return super().play(song_title, *args, **kwargs) + '\nYeah!'

    def what_do_you_do(self):
        """Just a simple method to describe the concept of singer.
        """

        return f'I am {self.name} and I sing songs.'


#%%
class Songwriter(Musician):
    """The class describing the concept of songwriter.
    It is assumed that a songwriter is sufficiently described as a musician
    who writes songs and plays an instrument.
    """

    def __init__(self, instrument=Instrument.RHYTHM_GUITAR, **kwargs):
        super().__init__(**kwargs)
        self.instrument = instrument if isinstance(instrument, Instrument) else None

    def __str__(self):
        v = f', {self.instrument.value}' if isinstance(self.instrument, Instrument) else ''
        return super().__str__() + v

    def __eq__(self, other):
        pass
        # Recommended if inheritance is involved
        # (https://stackoverflow.com/questions/390250/elegant-ways-to-support-equivalence-equality-in-python-classes):
        # if type(other) is type(self):
        #     return self.__dict__ == other.__dict__
        # return False

        return self.__dict__ == other.__dict__ if isinstance(other, Songwriter) else False

    def what_do_you_do(self):
        """Just a simple method to describe the concept of songwriter.
        """

        return f'I am {self.name} and I write songs.'


#%%
class SingerSongwriter(Singer, Songwriter):
    """The class describing the concept of singer-songwriter.
    It is assumed that a singer-songwriter is sufficiently described as a Singer who is simultaneously a Songwriter.

    Useful links :
    https://stackoverflow.com/a/50465583/1899061 (designing classes (i.e. their __init__() methods) for multiple inh.)
    https://stackoverflow.com/a/533675/1899061 (mixins explained, and what good they are in multiple inheritance)
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def __str__(self):
        return super().__str__()

    def __eq__(self, other):
        return self.__dict__ == other.__dict__ if isinstance(other, SingerSongwriter) else False

    def tell(self):
        """What if multiple inheritance requires calling a method with same method name
        from different paths (i.e., from different base classes)?
        E.g., class C(A, B) and both A and B implement a method with the same name m() in their own ways).
        In that case, call A's version like A.m(self), and B's version like B.m(self).
        """
        print(Singer.what_do_you_do(self))
        print(Songwriter.what_do_you_do(self))


